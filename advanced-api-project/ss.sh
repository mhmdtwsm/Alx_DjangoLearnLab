#!/bin/bash

# Django Advanced API Project Cleanup and Setup Script
# This script cleans up any partial installation and starts fresh

set -e  # Exit on any error

echo "🧹 Starting Django Advanced API Project Cleanup and Setup..."

# Check if we're in the correct directory
CURRENT_DIR=$(pwd)
EXPECTED_DIR="/home/mhmd/study/alx/Alx_DjangoLearnLab/advanced-api-project"

if [ "$CURRENT_DIR" != "$EXPECTED_DIR" ]; then
    echo "❌ Error: Please run this script from $EXPECTED_DIR"
    echo "Current directory: $CURRENT_DIR"
    exit 1
fi

echo "✅ Confirmed we're in the correct directory: $CURRENT_DIR"

# Step 1: Cleanup existing files (if any)
echo "🧹 Cleaning up any existing files..."
rm -rf advanced_api_project/
rm -f manage.py
rm -f db.sqlite3
rm -rf api/
rm -f requirements.txt
rm -f README.md

# Keep the virtual environment if it exists and is working
if [ -d "venv" ]; then
    echo "📦 Virtual environment already exists, checking if it works..."
    if source venv/bin/activate && python -c "import django, rest_framework" 2>/dev/null; then
        echo "✅ Existing virtual environment is working, using it"
    else
        echo "🔄 Existing virtual environment has issues, recreating..."
        rm -rf venv/
        python3 -m venv venv
        source venv/bin/activate
        pip install --upgrade pip
        pip install django djangorestframework
    fi
else
    echo "📦 Creating new Python virtual environment..."
    python3 -m venv venv
    source venv/bin/activate
    pip install --upgrade pip
    pip install django djangorestframework
fi

# Activate virtual environment
echo "🔧 Activating virtual environment..."
source venv/bin/activate

# Step 2: Create Django project
echo "🏗️  Creating Django project 'advanced_api_project'..."
django-admin startproject advanced_api_project .

# Verify project was created correctly
if [ ! -f "manage.py" ]; then
    echo "❌ Error: Django project creation failed. manage.py not found."
    exit 1
fi

if [ ! -d "advanced_api_project" ]; then
    echo "❌ Error: Django project directory not created."
    exit 1
fi

echo "✅ Django project created successfully"

# Step 3: Create Django app
echo "📱 Creating Django app 'api'..."
python manage.py startapp api

# Verify app was created correctly
if [ ! -d "api" ]; then
    echo "❌ Error: Django app creation failed. api/ directory not found."
    exit 1
fi

echo "✅ Django app 'api' created successfully"

# Step 4: Configure settings.py
echo "⚙️  Configuring settings.py..."
cat > advanced_api_project/settings.py << 'EOF'
"""
Django settings for advanced_api_project project.

Generated by 'django-admin startproject' using Django 5.2.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-advanced-api-project-change-this-in-production-12345'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',  # Django REST Framework
    'api',  # Our custom API app
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'advanced_api_project.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'advanced_api_project.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Django REST Framework Configuration
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ],
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
    ],
}
EOF

echo "✅ Settings configured successfully"

# Step 5: Create models.py
echo "📊 Creating models.py with Author and Book models..."
cat > api/models.py << 'EOF'
"""
Models for the Advanced API Project

This module defines the core data models for our book management system.
It demonstrates Django's ORM capabilities and establishes relationships
between Authors and Books using foreign keys.

Models:
- Author: Represents book authors with basic information
- Book: Represents books with publication details and author relationships
"""

from django.db import models
from django.core.validators import MaxValueValidator
from datetime import datetime


class Author(models.Model):
    """
    Author model representing book authors.
    
    This model stores basic information about authors and establishes
    a one-to-many relationship with books (one author can write many books).
    
    Fields:
        name (CharField): The full name of the author
    
    Methods:
        __str__: Returns the author's name for string representation
    """
    
    name = models.CharField(
        max_length=100,
        help_text="The full name of the author"
    )
    
    class Meta:
        ordering = ['name']  # Order authors alphabetically by name
        verbose_name = "Author"
        verbose_name_plural = "Authors"
    
    def __str__(self):
        """Return string representation of the author."""
        return self.name


class Book(models.Model):
    """
    Book model representing individual books in our system.
    
    This model stores book information and establishes a foreign key
    relationship with the Author model, allowing for one-to-many
    relationships (one author can have multiple books).
    
    Fields:
        title (CharField): The title of the book
        publication_year (IntegerField): The year the book was published
        author (ForeignKey): Reference to the Author who wrote this book
    
    Relationships:
        author: Many-to-One relationship with Author model
    
    Methods:
        __str__: Returns the book title for string representation
    """
    
    title = models.CharField(
        max_length=200,
        help_text="The title of the book"
    )
    
    publication_year = models.IntegerField(
        validators=[MaxValueValidator(datetime.now().year)],
        help_text="The year the book was published (cannot be in the future)"
    )
    
    author = models.ForeignKey(
        Author,
        on_delete=models.CASCADE,
        related_name='books',
        help_text="The author who wrote this book"
    )
    
    class Meta:
        ordering = ['-publication_year', 'title']  # Order by year (newest first), then title
        verbose_name = "Book"
        verbose_name_plural = "Books"
        # Ensure no duplicate books by the same author with the same title and year
        unique_together = ['title', 'author', 'publication_year']
    
    def __str__(self):
        """Return string representation of the book."""
        return f"{self.title} ({self.publication_year})"
EOF

echo "✅ Models created successfully"

# Step 6: Create serializers.py
echo "🔄 Creating serializers.py with custom serializers..."
cat > api/serializers.py << 'EOF'
"""
Serializers for the Advanced API Project

This module contains custom Django REST Framework serializers that handle
complex data structures and nested relationships between Author and Book models.

The serializers demonstrate advanced DRF concepts including:
- Custom validation methods
- Nested serialization of related objects
- Dynamic field handling
- Data transformation and representation

Serializers:
- BookSerializer: Handles Book model serialization with custom validation
- AuthorSerializer: Handles Author model with nested Book serialization
"""

from rest_framework import serializers
from datetime import datetime
from .models import Author, Book


class BookSerializer(serializers.ModelSerializer):
    """
    Custom serializer for the Book model.
    
    This serializer handles the serialization and deserialization of Book instances,
    including custom validation to ensure data integrity.
    
    Features:
    - Serializes all fields of the Book model
    - Custom validation for publication_year to prevent future dates
    - Proper handling of the author relationship
    
    Validation Rules:
    - publication_year cannot be in the future
    - All required fields must be provided
    """
    
    class Meta:
        model = Book
        fields = ['id', 'title', 'publication_year', 'author']
    
    def validate_publication_year(self, value):
        """
        Custom validation method for publication_year field.
        
        Ensures that the publication year is not in the future, as books
        cannot be published in years that haven't occurred yet.
        
        Args:
            value (int): The publication year to validate
            
        Returns:
            int: The validated publication year
            
        Raises:
            serializers.ValidationError: If the year is in the future
        """
        current_year = datetime.now().year
        
        if value > current_year:
            raise serializers.ValidationError(
                f"Publication year cannot be in the future. "
                f"Current year is {current_year}, but got {value}."
            )
        
        # Additional validation: reasonable minimum year
        if value < 1000:
            raise serializers.ValidationError(
                "Publication year seems too old. Please provide a reasonable year."
            )
        
        return value
    
    def validate(self, data):
        """
        Object-level validation for the entire Book instance.
        
        This method performs validation that requires access to multiple fields
        or complex business logic validation.
        
        Args:
            data (dict): Dictionary of field values to validate
            
        Returns:
            dict: Validated data dictionary
            
        Raises:
            serializers.ValidationError: If validation fails
        """
        # Example of object-level validation
        title = data.get('title', '').strip()
        if not title:
            raise serializers.ValidationError({
                'title': 'Book title cannot be empty or just whitespace.'
            })
        
        # Ensure title has reasonable length
        if len(title) < 2:
            raise serializers.ValidationError({
                'title': 'Book title must be at least 2 characters long.'
            })
        
        return data


class AuthorSerializer(serializers.ModelSerializer):
    """
    Custom serializer for the Author model with nested Book serialization.
    
    This serializer demonstrates advanced DRF concepts by including nested
    serialization of related Book objects. It dynamically includes all books
    written by the author using the reverse foreign key relationship.
    
    Features:
    - Serializes the Author's name field
    - Includes nested serialization of all related books
    - Uses the BookSerializer for consistent book representation
    - Handles the one-to-many relationship between Author and Books
    
    Nested Relationships:
    The 'books' field uses the related_name='books' defined in the Book model's
    foreign key relationship. This allows us to access all books by an author
    through the reverse relationship.
    """
    
    # Nested serializer field that includes all books by this author
    # The 'many=True' parameter indicates this is a one-to-many relationship
    # 'read_only=True' means this field won't be used for deserialization
    books = BookSerializer(many=True, read_only=True)
    
    class Meta:
        model = Author
        fields = ['id', 'name', 'books']
    
    def validate_name(self, value):
        """
        Custom validation method for the author name field.
        
        Ensures that author names meet basic quality standards.
        
        Args:
            value (str): The author name to validate
            
        Returns:
            str: The validated and cleaned author name
            
        Raises:
            serializers.ValidationError: If the name doesn't meet requirements
        """
        # Clean the name by stripping whitespace
        cleaned_name = value.strip()
        
        if not cleaned_name:
            raise serializers.ValidationError(
                "Author name cannot be empty or just whitespace."
            )
        
        if len(cleaned_name) < 2:
            raise serializers.ValidationError(
                "Author name must be at least 2 characters long."
            )
        
        # Check for reasonable maximum length
        if len(cleaned_name) > 100:
            raise serializers.ValidationError(
                "Author name is too long. Maximum 100 characters allowed."
            )
        
        return cleaned_name
    
    def to_representation(self, instance):
        """
        Custom method to control how the serialized data is represented.
        
        This method allows us to customize the output format and add
        additional computed fields or modify existing ones.
        
        Args:
            instance (Author): The Author instance being serialized
            
        Returns:
            dict: The serialized representation of the author
        """
        # Get the default representation
        representation = super().to_representation(instance)
        
        # Add a computed field showing the number of books
        representation['book_count'] = len(representation['books'])
        
        # Add the most recent publication year if books exist
        if representation['books']:
            latest_year = max(book['publication_year'] for book in representation['books'])
            representation['latest_publication_year'] = latest_year
        else:
            representation['latest_publication_year'] = None
        
        return representation


# Alternative simplified serializer for cases where nested data isn't needed
class AuthorBasicSerializer(serializers.ModelSerializer):
    """
    Basic serializer for Author model without nested books.
    
    This serializer provides a lightweight representation of authors
    without the overhead of loading and serializing all related books.
    Useful for list views or when only basic author information is needed.
    """
    
    book_count = serializers.SerializerMethodField()
    
    class Meta:
        model = Author
        fields = ['id', 'name', 'book_count']
    
    def get_book_count(self, obj):
        """
        SerializerMethodField to get the count of books by this author.
        
        Args:
            obj (Author): The author instance
            
        Returns:
            int: Number of books written by this author
        """
        return obj.books.count()
EOF

echo "✅ Serializers created successfully"

# Step 7: Create admin.py configuration
echo "👨‍💼 Setting up Django admin configuration..."
cat > api/admin.py << 'EOF'
"""
Django Admin Configuration for Advanced API Project

This module configures the Django admin interface for our Author and Book models,
providing an easy-to-use interface for managing data during development and testing.
"""

from django.contrib import admin
from .models import Author, Book


@admin.register(Author)
class AuthorAdmin(admin.ModelAdmin):
    """
    Admin configuration for the Author model.
    
    Provides a comprehensive interface for managing authors with
    enhanced display and filtering options.
    """
    
    list_display = ['name', 'book_count']
    search_fields = ['name']
    ordering = ['name']
    
    def book_count(self, obj):
        """Display the number of books by this author."""
        return obj.books.count()
    book_count.short_description = 'Number of Books'


@admin.register(Book)
class BookAdmin(admin.ModelAdmin):
    """
    Admin configuration for the Book model.
    
    Provides a comprehensive interface for managing books with
    enhanced display, filtering, and search options.
    """
    
    list_display = ['title', 'author', 'publication_year']
    list_filter = ['publication_year', 'author']
    search_fields = ['title', 'author__name']
    ordering = ['-publication_year', 'title']
    list_select_related = ['author']  # Optimize database queries
    
    fieldsets = (
        ('Book Information', {
            'fields': ('title', 'publication_year')
        }),
        ('Author Information', {
            'fields': ('author',)
        }),
    )
EOF

echo "✅ Admin configuration created successfully"

# Step 8: Create test_models.py for testing
echo "🧪 Creating test file for models and serializers..."
cat > api/test_models.py << 'EOF'
"""
Test script for manually testing models and serializers.

This script can be run in Django shell to test the functionality
of our models and serializers.

Usage:
    python manage.py shell
    exec(open('api/test_models.py').read())
"""

from datetime import datetime
from api.models import Author, Book
from api.serializers import AuthorSerializer, BookSerializer

def test_models_and_serializers():
    """
    Test function to verify models and serializers work correctly.
    """
    print("🧪 Testing Models and Serializers...")
    
    # Test creating an author
    print("\n📝 Creating test author...")
    author = Author.objects.create(name="J.K. Rowling")
    print(f"✅ Created author: {author}")
    
    # Test creating books
    print("\n📚 Creating test books...")
    book1 = Book.objects.create(
        title="Harry Potter and the Philosopher's Stone",
        publication_year=1997,
        author=author
    )
    book2 = Book.objects.create(
        title="Harry Potter and the Chamber of Secrets",
        publication_year=1998,
        author=author
    )
    print(f"✅ Created books: {book1}, {book2}")
    
    # Test BookSerializer
    print("\n🔄 Testing BookSerializer...")
    book_serializer = BookSerializer(book1)
    print(f"Book serialized data: {book_serializer.data}")
    
    # Test AuthorSerializer with nested books
    print("\n🔄 Testing AuthorSerializer...")
    author_serializer = AuthorSerializer(author)
    print(f"Author serialized data: {author_serializer.data}")
    
    # Test validation
    print("\n✅ Testing custom validation...")
    try:
        future_year = datetime.now().year + 1
        invalid_book_data = {
            'title': 'Future Book',
            'publication_year': future_year,
            'author': author.id
        }
        book_serializer = BookSerializer(data=invalid_book_data)
        if not book_serializer.is_valid():
            print(f"✅ Validation working correctly. Errors: {book_serializer.errors}")
        else:
            print("❌ Validation should have failed for future year")
    except Exception as e:
        print(f"❌ Error during validation test: {e}")
    
    print("\n🎉 All tests completed!")

# Run tests if executed directly
if __name__ == "__main__":
    test_models_and_serializers()
EOF

echo "✅ Test file created successfully"

# Step 9: Run initial migrations
echo "🗄️  Creating and running initial migrations..."
python manage.py makemigrations
python manage.py migrate

# Step 10: Create superuser (optional, for admin access)
echo "👨‍💼 Creating superuser for admin access..."
echo "You can create a superuser now or skip this step."
read -p "Do you want to create a superuser? (y/n): " create_superuser

if [ "$create_superuser" = "y" ] || [ "$create_superuser" = "Y" ]; then
    python manage.py createsuperuser
else
    echo "⏭️  Skipping superuser creation. You can create one later with 'python manage.py createsuperuser'"
fi

# Step 11: Generate requirements.txt
echo "📋 Generating requirements.txt..."
pip freeze > requirements.txt

# Step 12: Create a README file
echo "📖 Creating README.md with project documentation..."
cat > README.md << 'EOF'
# Advanced API Project - Django REST Framework

This project demonstrates advanced Django REST Framework concepts including custom serializers, nested relationships, and data validation.

## Project Structure

```
advanced-api-project/
├── venv/                          # Virtual environment
├── advanced_api_project/          # Django project directory
│   ├── __init__.py
│   ├── settings.py               # Project settings
│   ├── urls.py                   # URL configuration
│   ├── wsgi.py                   # WSGI configuration
│   └── asgi.py                   # ASGI configuration
├── api/                          # Django app
│   ├── __init__.py
│   ├── models.py                 # Author and Book models
│   ├── serializers.py            # Custom serializers
│   ├── admin.py                  # Admin configuration
│   ├── test_models.py            # Test script
│   └── views.py                  # API views (to be implemented)
├── manage.py                     # Django management script
├── requirements.txt              # Python dependencies
└── README.md                     # This file
```

## Models

### Author
- `name`: CharField - The author's full name
- Relationship: One-to-many with Books

### Book
- `title`: CharField - The book's title
- `publication_year`: IntegerField - Year of publication (validated)
- `author`: ForeignKey - Reference to Author model

## Serializers

### BookSerializer
- Serializes all Book fields
- Custom validation for `publication_year` (prevents future dates)
- Object-level validation for data integrity

### AuthorSerializer
- Includes nested BookSerializer for related books
- Shows author information with all their books
- Computed fields: `book_count`, `latest_publication_year`

## Setup and Usage

### 1. Activate Virtual Environment
```bash
source venv/bin/activate
```

### 2. Run Development Server
```bash
python manage.py runserver
```

### 3. Access Admin Interface
- URL: http://127.0.0.1:8000/admin/
- Create a superuser if you haven't: `python manage.py createsuperuser`

### 4. Test Models and Serializers
```bash
python manage.py shell
exec(open('api/test_models.py').read())
```

### 5. Django Shell Commands
```python
# Create test data
from api.models import Author, Book
from api.serializers import AuthorSerializer, BookSerializer

# Create an author
author = Author.objects.create(name="George Orwell")

# Create books
book1 = Book.objects.create(title="1984", publication_year=1949, author=author)
book2 = Book.objects.create(title="Animal Farm", publication_year=1945, author=author)

# Test serializers
author_serializer = AuthorSerializer(author)
print(author_serializer.data)
```

## Key Features Demonstrated

1. **Custom Model Relationships**: One-to-many relationship between Author and Book
2. **Advanced Serializers**: Nested serialization with BookSerializer inside AuthorSerializer
3. **Custom Validation**: Publication year validation in BookSerializer
4. **Dynamic Fields**: Computed fields like book count and latest publication year
5. **Admin Integration**: Customized Django admin for easy data management
6. **Data Integrity**: Unique constraints and proper validation

## Next Steps

- Implement API views and URL routing
- Add authentication and permissions
- Create API endpoints for CRUD operations
- Add pagination and filtering
- Implement API documentation with Django REST Framework's browsable API

## Dependencies

- Django
- Django REST Framework

See `requirements.txt` for specific versions.
EOF

echo "✅ README created successfully"

# Step 13: Final verification
echo "🔍 Running final verification..."
python manage.py check

echo ""
echo "✅ All files created and verified successfully!"
echo ""
echo "🎉 Django Advanced API Project Setup Complete!"
echo ""
echo "📋 Summary of what was created:"
echo "  ✅ Python virtual environment (venv/)"
echo "  ✅ Django project 'advanced_api_project'"
echo "  ✅ Django app 'api'"
echo "  ✅ Author and Book models with relationships"
echo "  ✅ Custom serializers with validation"
echo "  ✅ Django admin configuration"
echo "  ✅ Database migrations"
echo "  ✅ Test script for manual testing"
echo "  ✅ Requirements.txt"
echo "  ✅ Comprehensive README.md"
echo ""
echo "🚀 Next steps:"
echo "  1. Make sure virtual environment is active: source venv/bin/activate"
echo "  2. Start development server: python manage.py runserver"
echo "  3. Test in Django shell: python manage.py shell"
echo "  4. Access admin at: http://127.0.0.1:8000/admin/"
echo ""
echo "🧪 To test models and serializers:"
echo "  python manage.py shell"
echo "  exec(open('api/test_models.py').read())"
echo ""
echo "Happy coding! 🐍✨"
